	a. 创建型:
		a. 单例模式：
			a. 某个类只能有一个实例，提供一个全局的访问点
			b. 私有化构造，提供一个唯一获取实例对象的方法
		b. 工厂模式：
			a. 简单工厂 :  一个工厂类根据传入的参量决定创建出那一种产品类的实例。
			b. 工厂方法 : 定义一个创建对象的接口，让子类决定实例化那个类。
			c. 抽象工厂 : 创建相关或依赖对象的家族，而无需明确指定具体类。
			d. 就是提供了一个Map，根据一个特定的key值，找一个特定的Bean
			e. 发送邮件和短信
		c. 建造者模式：
			a. 封装一个复杂对象的构建过程，并可以按步骤构造 , 使一个复杂对象的构建与表示分开 , 隐藏创建过程
			b. 把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。
			c. 比工厂模式则多一个调度者角色
		d. 原型模式：通过复制现有的实例来创建新的实例 , 分为浅复制和深复制
	
	b. 结构型:
		a. 适配器模式：
			a. 将一个类的方法接口转换成客户希望的另外一个接口。
			b. 类的适配器模式
				1) 有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，
				2) 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
			c. 对象的适配器模式
				1) 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题
				2) 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。
			d. 接口的适配器模式
				1) 借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系。
				2) 所以我们写一个类，继承该抽象类，重写我们需要的方法就行。
				3) 当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可
			
		b. 组合模式：
			a. 将对象组合成树形结构以表示“”部分-整体“”的层次结构。常用于表示树形结构中 ,
			b. 使得用户对单个对象和组合对象的使用具有一致性。
			
		c. 装饰模式：
			a. 动态的给对象添加新的功能。构造方法中引入待装饰者的对象, 扩展待装饰者的方法
			b. 需要扩展一个类的功能 或者动态的为一个对象增加功能, 但是会产生过多的相似对象, 不易排错
		d. 代理模式：
			a. 为其他对象提供一个代理以便控制这个对象的访问并可以增加额外的操作, 即扩展目标对象的功能。
			b. 静态代理 : 需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类. 调用的时候通过调用代理对象的方法来调用目标对象.
			c. 动态代理 : 代理对象,不需要实现相同接口 , 但是目标对象要实现接口
			代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
			d. Cglib代理 : 被代理对象不需要实现接口
			也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.
			Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类
			
		e. 亨元（蝇量）模式：
			a. 以共享的方式高效地支持大量的细粒度对象。
			b. 主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。
		
		f. 外观模式：
			a. 对外提供一个统一的方法，来访问子系统中的一群接口。
			b. 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，如果多个类之间相互持有实例 , 则可以考虑将这些类统一一个管理类来维护
			c. 而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。
			
		g. 桥接模式：
			a. 将抽象部分和它的实现部分分离，使它们都可以独立的变化。
			b. 桥接模式使用对象见的组合关系解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
			
			c. 应用场景 :
				1) 桥接模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换而言之两个变化不会导致纵横交错的结果，并不一定要使用桥接模式。
				2) 如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。
				3) 如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。
				4) 如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。
				5) 如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。
				
			d. Jdk中的桥接模式：JDBC
				1) JDBC连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了
			
			
	
	c. 行为模式型
		a. 模板模式：
			a. 定义一个算法结构，而将一些步骤延迟到子类实现。
			b. 一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，
			定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用,
			c. 模板模式是典型的面向抽象编程，在抽象阶段将系统的不变部分（如步骤顺序）确定下来，变化部分（如步骤具体内容）交给子类。
			
		b. 解释器模式：
			a. 给定一个语言，定义它的文法的一种表示，并定义一个解释器。
			b. 解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等
		c. 策略模式：
			a. 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。
			b. 策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。
			
		d. 状态模式：
			a. 允许一个对象在其对象内部状态改变时改变它的行为。
			b. 核心思想就是：当对象的状态改变时，同时改变其行为。
			主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。
			把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化
			
			c. 将于特定状态相关的行为局部化，并且将不同状态的行为分割开来，将特定的状态相关的行为都放入一个对象中，由于所有状态相关的代码都存在于某个concreteState中，所以通过定义新的子类可以很容易的增加新的状态和转换
			状态模式通过把各个状态转移逻辑分布到State的子类中，来减少相互依赖
			当一个对象的行为取决于状态，并且它必须在运行时根据状态改变它的行为，就可以考虑使用状态模式
			
		e. 观察者模式：
			a. 对象间的一对多的依赖关系，让多个观察者对象同时监听某一个主题对象
			b. 这个主题对象在状态上发生变化时，会通知所有观察者对象，让他们能够自动更新自己
			
		f. 备忘录模式：
			a. 在不破坏封装的前提下，保持对象的内部状态。
			b. 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象
			通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，
			类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。
			
		g. 中介者模式：
			a. 用一个中介对象来封装一系列的对象交互。
			b. 中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。
			如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。
			
		h. 命令模式：
			a. 将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
			b. 如果我们用一个类，来表示“进行某项工作”的命令，那么每一项工作就不在是“方法的调用”，而是一个表示命令的类的实例。如果想要管理工作的历史记录，只需要管理这些实例的集合即可，而且还可以随时再次执行过去的命令，或者是将过去的命令整合成一个新命令并执行。
			
		i. 访问者模式：
			a. 在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
			b. 访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，
			若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。
			c. 访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。
			其缺点就是增加新的数据结构很困难。
			
		j. 责任链模式：
			a. 将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
			b. 责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。
			但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。
			c. 链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。
			
		k. 迭代器模式：
			a. 一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
      b. 迭代器模式就是顺序访问聚集中的对象。一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。
